{
    "django__django-10914": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-10914",
        "model_patch": "diff --git a/django/conf/global_settings.py b/django/conf/global_settings.py\nindex acee9887d2..b875732d70 100644\n--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -38,6 +38,12 @@ ALLOWED_HOSTS = []\n # https://en.wikipedia.org/wiki/List_of_tz_zones_by_name (although not all\n # systems may support all possibilities). When USE_TZ is True, this is\n # interpreted as the default user time zone.\n+\n+\n+# Default file upload permissions\n+FILE_UPLOAD_PERMISSIONS = 0o644\n+FILE_UPLOAD_DIRECTORY_PERMISSIONS = 0o755\n+\n TIME_ZONE = 'America/Chicago'\n \n # If you set this to True, Django will use timezone-aware datetimes.\n"
    },
    "django__django-10924": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-10924",
        "model_patch": ""
    },
    "django__django-11001": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-11001",
        "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 7649c39262..98b509a3a8 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -366,7 +366,8 @@ class SQLCompiler:\n         if self.query.distinct and not self.query.distinct_fields:\n             select_sql = [t[1] for t in select]\n             for expr, (sql, params, is_ref) in order_by:\n-                without_ordering = self.ordering_parts.search(sql).group(1)\n+                sql_oneline = ' '.join(sql.splitlines())\n+                without_ordering = self.ordering_parts.search(sql_oneline).group(1)\n                 if not is_ref and (without_ordering, params) not in select_sql:\n                     extra_select.append((expr, (without_ordering, params), None))\n         return extra_select\n"
    },
    "django__django-11019": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-11019",
        "model_patch": "diff --git a/django/forms/widgets.py b/django/forms/widgets.py\nindex 02aa32b207..3135bd41e7 100644\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -114,6 +114,7 @@ class Media:\n             return Media(**{str(name): getattr(self, '_' + name)})\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n+\n     @staticmethod\n     def merge(list_1, list_2):\n         \"\"\"\n@@ -125,29 +126,65 @@ class Media:\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n-                    warnings.warn(\n-                        'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n-                        MediaOrderConflictWarning,\n-                    )\n-                # path already exists in the list. Update last_insert_index so\n-                # that the following elements are inserted in front of this one.\n-                last_insert_index = index\n-        return combined_list\n+        # This new implementation merges two lists by building a graph of order constraints\n+        # and then performing a topological sort to find a consistent order.\n+\n+        from collections import defaultdict, deque\n+\n+        # Build graph and in-degree count\n+        graph = defaultdict(set)\n+        in_degree = defaultdict(int)\n+\n+        # Add all nodes\n+        all_nodes = list_1 + [item for item in list_2 if item not in list_1]\n+        for node in all_nodes:\n+            in_degree[node] = 0\n+\n+        # Add edges from list_1\n+        for i in range(len(list_1) - 1):\n+            if list_1[i+1] not in graph[list_1[i]]:\n+                graph[list_1[i]].add(list_1[i+1])\n+                in_degree[list_1[i+1]] += 1\n+\n+        # Add edges from list_2\n+        for i in range(len(list_2) - 1):\n+            if list_2[i+1] not in graph[list_2[i]]:\n+                graph[list_2[i]].add(list_2[i+1])\n+                in_degree[list_2[i+1]] += 1\n+\n+        # Topological sort\n+        queue = deque([node for node in all_nodes if in_degree[node] == 0])\n+        result = []\n+\n+        while queue:\n+            node = queue.popleft()\n+            result.append(node)\n+            for neighbor in graph[node]:\n+                in_degree[neighbor] -= 1\n+                if in_degree[neighbor] == 0:\n+                    queue.append(neighbor)\n+\n+        if len(result) != len(all_nodes):\n+            # There is a cycle, try to find the conflicting pair\n+            # We do this by checking pairs in list_1 and list_2\n+            conflict_found = False\n+            for i in range(len(list_1)):\n+                for j in range(i + 1, len(list_1)):\n+                    if list_1[i] in list_2 and list_1[j] in list_2:\n+                        if list_2.index(list_1[i]) > list_2.index(list_1[j]):\n+                            warnings.warn(\n+                                'Detected duplicate Media files in an opposite order:\\n%s\\n%s' % (list_1[i], list_1[j]),\n+                                MediaOrderConflictWarning,\n+                            )\n+                            conflict_found = True\n+                            break\n+                if conflict_found:\n+                    break\n+            # Fallback to concatenation\n+            result = list_1 + [item for item in list_2 if item not in list_1]\n+\n+        return result\n+\n \n     def __add__(self, other):\n         combined = Media()\n"
    },
    "django__django-11039": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-11039",
        "model_patch": "diff --git a/django/core/management/commands/sqlmigrate.py b/django/core/management/commands/sqlmigrate.py\nindex f0b663222a..3156c4aa65 100644\n--- a/django/core/management/commands/sqlmigrate.py\n+++ b/django/core/management/commands/sqlmigrate.py\n@@ -55,8 +55,8 @@ class Command(BaseCommand):\n                 migration_name, app_label))\n         targets = [(app_label, migration.name)]\n \n-        # Show begin/end around output only for atomic migrations\n-        self.output_transaction = migration.atomic\n+        # Show begin/end around output only for atomic migrations or if the schema editor can rollback DDL\n+        self.output_transaction = migration.atomic and connection.features.can_rollback_ddl\n \n         # Make a plan that represents just the requested migrations and show SQL\n         # for it\n"
    },
    "django__django-11049": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-11049",
        "model_patch": "diff --git a/django/forms/fields.py b/django/forms/fields.py\nindex a977256525..dbb1404f91 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -468,10 +468,15 @@ class DateTimeField(BaseTemporalField):\n \n class DurationField(Field):\n     default_error_messages = {\n-        'invalid': _('Enter a valid duration.'),\n+        'invalid': _('Enter a valid duration. The expected format is [DD] [[HH:]MM:]ss[.uuuuuu].'),\n         'overflow': _('The number of days must be between {min_days} and {max_days}.')\n     }\n \n+    def __init__(self, *args, **kwargs):\n+        if 'help_text' not in kwargs:\n+            kwargs['help_text'] = _('Duration format: [DD] [[HH:]MM:]ss[.uuuuuu]')\n+        super().__init__(*args, **kwargs)\n+\n     def prepare_value(self, value):\n         if isinstance(value, datetime.timedelta):\n             return duration_string(value)\n"
    },
    "django__django-11099": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-11099",
        "model_patch": "diff --git a/django/contrib/auth/validators.py b/django/contrib/auth/validators.py\nindex b4878cfd45..dd15050813 100644\n--- a/django/contrib/auth/validators.py\n+++ b/django/contrib/auth/validators.py\n@@ -7,7 +7,7 @@ from django.utils.translation import gettext_lazy as _\n \n @deconstructible\n class ASCIIUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only English letters, '\n         'numbers, and @/./+/-/_ characters.'\n@@ -17,9 +17,10 @@ class ASCIIUsernameValidator(validators.RegexValidator):\n \n @deconstructible\n class UnicodeUsernameValidator(validators.RegexValidator):\n-    regex = r'^[\\w.@+-]+$'\n+    regex = r'\\A[\\w.@+-]+\\Z'\n     message = _(\n         'Enter a valid username. This value may contain only letters, '\n         'numbers, and @/./+/-/_ characters.'\n     )\n     flags = 0\n+\n"
    },
    "django__django-11133": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-11133",
        "model_patch": "diff --git a/django/http/response.py b/django/http/response.py\nindex 6a84e193ba..2b97587462 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -308,8 +308,11 @@ class HttpResponse(HttpResponseBase):\n \n     @content.setter\n     def content(self, value):\n+        # Special case for memoryview to convert to bytes directly\n+        if isinstance(value, memoryview):\n+            content = value.tobytes()\n         # Consume iterators upon assignment to allow repeated iteration.\n-        if hasattr(value, '__iter__') and not isinstance(value, (bytes, str)):\n+        elif hasattr(value, '__iter__') and not isinstance(value, (bytes, str)):\n             content = b''.join(self.make_bytes(chunk) for chunk in value)\n             if hasattr(value, 'close'):\n                 try:\n"
    },
    "django__django-11179": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-11179",
        "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 92fe4affb9..89a17eccee 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -277,6 +277,7 @@ class Collector:\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n+                    instance.pk = None\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\ndiff --git a/reproduce_delete_pk_clear.py b/reproduce_delete_pk_clear.py\nnew file mode 100644\nindex 0000000000..28be86f732\n--- /dev/null\n+++ b/reproduce_delete_pk_clear.py\n@@ -0,0 +1,41 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models\n+\n+# Minimal Django settings for testing\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        '__main__',\n+    ],\n+)\n+\n+django.setup()\n+\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=100)\n+\n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+# Create the table\n+with django.db.connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(TestModel)\n+\n+# Create an instance\n+obj = TestModel.objects.create(name='test')\n+print(f'Before delete: PK = {obj.pk}')\n+\n+# Delete the instance\n+obj.delete()\n+print(f'After delete: PK = {obj.pk}')\n+\n+# The PK should be None after deletion\n+assert obj.pk is None, \"PK was not cleared after delete()\"\n\\ No newline at end of file\n"
    },
    "django__django-11283": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-11283",
        "model_patch": "diff --git a/django/contrib/auth/migrations/0011_update_proxy_permissions.py b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\nindex 0e66649695..4cbbac819f 100644\n--- a/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n+++ b/django/contrib/auth/migrations/0011_update_proxy_permissions.py\n@@ -27,7 +27,7 @@ def update_proxy_model_permissions(apps, schema_editor, reverse=False):\n         Permission.objects.filter(\n             permissions_query,\n             content_type=old_content_type,\n-        ).update(content_type=new_content_type)\n+        ).exclude(content_type=new_content_type).update(content_type=new_content_type)\n \n \n def revert_proxy_model_permissions(apps, schema_editor):\n"
    },
    "django__django-11422": {
        "model_name_or_path": "default__gpt-4.1-mini__t-0.00__p-1.00__c-0.50___swe_bench_lite_test",
        "instance_id": "django__django-11422",
        "model_patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\nindex 7ca0d68fae..6f8b0f3b87 100644\n--- a/django/utils/autoreload.py\n+++ b/django/utils/autoreload.py\n@@ -221,6 +221,10 @@ class BaseReloader:\n         self.extra_files = set()\n         self.directory_globs = defaultdict(set)\n         self._stop_condition = threading.Event()\n+        # Explicitly watch manage.py if it exists in the current working directory\n+        manage_py = Path(os.getcwd()) / 'manage.py'\n+        if manage_py.exists():\n+            self.extra_files.add(manage_py)\n \n     def watch_dir(self, path, glob):\n         path = Path(path)\ndiff --git a/tests/i18n/sampleproject/manage.py b/tests/i18n/sampleproject/manage.py\nindex 87a0ec369a..7710c1187d 100755\n--- a/tests/i18n/sampleproject/manage.py\n+++ b/tests/i18n/sampleproject/manage.py\n@@ -10,3 +10,4 @@ if __name__ == \"__main__\":\n     from django.core.management import execute_from_command_line\n \n     execute_from_command_line(sys.argv)\n+\ndiff --git a/tests/i18n/sampleproject/test_manage_py_reload.py b/tests/i18n/sampleproject/test_manage_py_reload.py\nnew file mode 100644\nindex 0000000000..aeab5f440c\n--- /dev/null\n+++ b/tests/i18n/sampleproject/test_manage_py_reload.py\n@@ -0,0 +1,30 @@\n+import os\n+import time\n+from threading import Thread\n+\n+def run_server():\n+    os.system('python tests/i18n/sampleproject/manage.py runserver --noreload')\n+\n+# Run the server in a separate thread\n+server_thread = Thread(target=run_server)\n+server_thread.start()\n+\n+# Wait for the server to start\n+time.sleep(5)\n+\n+# Modify the manage.py file to trigger reload\n+manage_py_path = 'tests/i18n/sampleproject/manage.py'\n+with open(manage_py_path, 'a') as f:\n+    f.write('\\n# Trigger reload test\\n')\n+\n+# Wait to observe if the server reloads\n+time.sleep(10)\n+\n+# Cleanup: remove the added line\n+with open(manage_py_path, 'r') as f:\n+    lines = f.readlines()\n+with open(manage_py_path, 'w') as f:\n+    f.writelines(lines[:-1])\n+\n+server_thread.join()\n+\n"
    }
}